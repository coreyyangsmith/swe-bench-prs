[
    {
        "repo": "DataDog/integrations-core",
        "instance_id": "DataDog__integrations-core-9857",
        "base_commit": "8006a053c108af2cf1988efe23db8f58df8262dc",
        "patch": "diff --git a/mongo/datadog_checks/mongo/collectors/custom_queries.py b/mongo/datadog_checks/mongo/collectors/custom_queries.py\n--- a/mongo/datadog_checks/mongo/collectors/custom_queries.py\n+++ b/mongo/datadog_checks/mongo/collectors/custom_queries.py\n@@ -56,8 +56,10 @@ def _collect_custom_metrics_for_query(self, api, raw_query):\n         mongo_query = deepcopy(raw_query.get('query'))\n         if not mongo_query:  # no cov\n             raise ValueError(\"Custom query field `query` is required\")\n+        # The mongo command to run (find, aggregate, count...)\n         mongo_command = self._extract_command_from_mongo_query(mongo_query)\n-        collection_name = mongo_query[mongo_command]\n+        # The value of the command, it is usually the collection name on which to run the query.\n+        mongo_command_value = mongo_query[mongo_command]\n         del mongo_query[mongo_command]\n         if mongo_command not in ALLOWED_CUSTOM_QUERIES_COMMANDS:\n             raise ValueError(\"Custom query command must be of type {}\".format(ALLOWED_CUSTOM_QUERIES_COMMANDS))\n@@ -90,20 +92,26 @@ def _collect_custom_metrics_for_query(self, api, raw_query):\n             if field_type not in ALLOWED_CUSTOM_METRICS_TYPES + ['tag']:\n                 raise ValueError('Field `type` must be one of {}'.format(ALLOWED_CUSTOM_METRICS_TYPES + ['tag']))\n \n-        tags = list(tags)\n-        tags.extend(raw_query.get('tags', []))\n-        tags.append('collection:{}'.format(collection_name))\n-\n         try:\n             # This is where it is necessary to extract the command and its argument from the query to pass it as the\n             # first two params.\n-            result = db.command(mongo_command, collection_name, **mongo_query)\n+            result = db.command(mongo_command, mongo_command_value, **mongo_query)\n             if result['ok'] == 0:\n                 raise pymongo.errors.PyMongoError(result['errmsg'])\n         except pymongo.errors.PyMongoError:\n             self.log.error(\"Failed to run custom query for metric %s\", metric_prefix)\n             raise\n \n+        # `1` is Mongo default value for commands that are collection agnostics.\n+        if str(mongo_command_value) == '1':\n+            # https://github.com/mongodb/mongo-python-driver/blob/01e34cebdb9aac96c72ddb649e9b0040a0dfd3a0/pymongo/aggregation.py#L208\n+            collection_name = '{}.{}'.format(db_name, mongo_command)\n+        else:\n+            collection_name = mongo_command_value\n+\n+        tags.append('collection:{}'.format(collection_name))\n+        tags.extend(raw_query.get('tags', []))\n+\n         if mongo_command == 'count':\n             # A count query simply returns a number, no need to iterate through it.\n             submit_method(metric_prefix, result['n'], tags)\n",
        "test_patch": "",
        "problem_statement": "MongoDB: Collection-agnostic aggregations like $currentOp doesn't work\nAgent 7.29.1, running on Ubuntu Linux 18.04.\r\n\r\n**Steps to reproduce the issue:**\r\nAdd the following configuration to `/etc/datadog-agent/conf.d/mongo.d/conf.yaml` and restart the agent:\r\n```\r\n    custom_queries:\r\n      - metric_prefix: mongodb.custom.queries_slower_than_60sec\r\n        run_on_secondary: true\r\n        query: { \"aggregate\": 1, \"maxTimeMS\": 1000, \"pipeline\": [ { \"$currentOp\": { \"allUsers\": true }}, { \"$match\": { \"active\": true, \"secs_running\": {\"$gt\": 60}}} ], \"cursor\": {}}\r\n        fields:\r\n        - field_name: secs_running\r\n          name: secs_running\r\n          type: gauge\r\n        - field_name: appName\r\n          name: app_name\r\n          type: tag\r\n        - field_name: ns\r\n          name: mongo_op_namespace\r\n          type: tag\r\n```\r\n\r\n**Describe the results you received:**\r\nWhen Datadog attempts to run this command, it produces an error (found via `journalctl`):\r\n```\r\nTraceback (most recent call last):\r\n2021-07-22 06:44:38 UTC | CORE | WARN | (pkg/collector/python/datadog_agent.go:122 in LogMessage) | mongo:375a6f2e54dabf11 | (custom_queries.py:153) | Errors while collecting custom metrics with prefix mongodb.custom.queries_slower_than_60sec\r\nTypeError: name must be an instance of str\r\n    raise TypeError(\"name must be an instance \"\r\n  File \"/opt/datadog-agent/embedded/lib/python3.8/site-packages/pymongo/collection.py\", line 160, in __init__\r\n    pymongo.collection.Collection(db, collection_name), result['cursor'], None\r\n  File \"/opt/datadog-agent/embedded/lib/python3.8/site-packages/datadog_checks/mongo/collectors/custom_queries.py\", line 113, in _collect_custom_metrics_for_query\r\n    self._collect_custom_metrics_for_query(api, raw_query)\r\n  File \"/opt/datadog-agent/embedded/lib/python3.8/site-packages/datadog_checks/mongo/collectors/custom_queries.py\", line 150, in collect\r\n```\r\n\r\n**Describe the results you expected:**\r\nI would like to be able to send information about slow queries to Datadog.\r\n\r\n**Additional information you deem important (e.g. issue happens only occasionally):**\r\nIt seems like the problem here is that when using this syntax to run an admin aggregation like `$currentOp`, you have to specify `\"aggregate\": 1` in the query to indicate that there is no associated collection. However, the API that Datadog is calling in pymongo expects the collection name to always be a string. Unfortunately, `\"aggregate\": \"1\"` is not equivalent and will fail.\r\n\r\nMore details on the syntax: https://docs.mongodb.com/manual/reference/command/aggregate/\n",
        "hints_text": "Hey @atodd-circleci \r\nAcknowledging the limitation, I'm able to reproduce.\r\nI'm thinking we should be able to work around that by putting `$cmd.aggregate` instead of \"1\" as the collection name here: https://github.com/DataDog/integrations-core/blob/master/mongo/datadog_checks/mongo/collectors/custom_queries.py#L113 but I'd have to confirm that\n@FlorianVeaux Thanks for taking a look so quickly. I manually edited `custom_queries.py` on my installation to replace `collection_name` with the literal `$cmd.aggregate`. It seems to have worked. When I start the agent, I see this in the log:\r\n\r\n```\r\nException: Custom query returned an empty result set.\r\n    raise Exception('Custom query returned an empty result set.')\r\n  File \"/opt/datadog-agent/embedded/lib/python3.8/site-packages/datadog_checks/mongo/collectors/custom_queries.py\", line 145, in _collect_custom_metrics_for_query\r\n    self._collect_custom_metrics_for_query(api, raw_query)\r\n  File \"/opt/datadog-agent/embedded/lib/python3.8/site-packages/datadog_checks/mongo/collectors/custom_queries.py\", line 150, in collect\r\nTraceback (most recent call last):\r\n2021-07-27 05:20:05 UTC | CORE | WARN | (pkg/collector/python/datadog_agent.go:122 in LogMessage) | mongo:<redacted> | (custom_queries.py:153) | Errors while collecting custom metrics with prefix mongodb.custom.queries_slower_than_60sec\r\n```\r\n\r\nI'm not expecting any results, so this is good. I can't really go around manually editing our installations this way, though, so I'm looking forward to a more permanent fix.\r\n\r\n(I am a little concerned about having all of these exceptions in the system log, as well. I'll have to look at using [$count](https://docs.mongodb.com/manual/reference/operator/aggregation/count/) to always output a count instead of what I'm doing now).",
        "created_at": "2021-08-05T15:17:59Z",
        "version": "",
        "FAIL_TO_PASS": "[]",
        "PASS_TO_PASS": "[]",
        "environment_setup_commit": "",
        "reviews": "We don't test these metrics currently right?\n",
        "dev_num": 0,
        "review_num": 1,
        "gpt_code": "python\ndiff --git a/mongo/datadog_checks/mongo/collectors/custom_queries.py b/mongo/datadog_checks/mongo/collectors/custom_queries.py\n--- a/mongo/datadog_checks/mongo/collectors/custom_queries.py\n+++ b/mongo/datadog_checks/mongo/collectors/custom_queries.py\n@@ -56,8 +56,10 @@ def _collect_custom_metrics_for_query(self, api, raw_query):\n         mongo_query = deepcopy(raw_query.get('query'))\n         if not mongo_query:  # no cov\n             raise ValueError(\"Custom query field `query` is required\")\n+        # The mongo command to run (find, aggregate, count...)\n         mongo_command = self._extract_command_from_mongo_query(mongo_query)\n-        collection_name = mongo_query[mongo_command]\n+        # The value of the command, it is usually the collection name on which to run the query.\n+        mongo_command_value = mongo_query[mongo_command]\n         del mongo_query[mongo_command]\n         if mongo_command not in ALLOWED_CUSTOM_QUERIES_COMMANDS:\n             raise ValueError(\"Custom query command must be of type {}\".format(ALLOWED_CUSTOM_QUERIES_COMMANDS))\n@@ -90,20 +92,26 @@ def _collect_custom_metrics_for_query(self, api, raw_query):\n             if field_type not in ALLOWED_CUSTOM_METRICS_TYPES + ['tag']:\n                 raise ValueError('Field `type` must be one of {}'.format(ALLOWED_CUSTOM_METRICS_TYPES + ['tag']))\n \n-        tags = list(tags)\n-        tags.extend(raw_query.get('tags', []))\n-        tags.append('collection:{}'.format(collection_name))\n-\n         try:\n             # This is where it is necessary to extract the command and its argument from the query to pass it as the\n             # first two params.\n-            result = db.command(mongo_command, collection_name, **mongo_query)\n+            result = db.command(mongo_command, mongo_command_value, **mongo_query)\n             if result['ok'] == 0:\n                 raise pymongo.errors.PyMongoError(result['errmsg'])\n         except pymongo.errors.PyMongoError:\n             self.log.error(\"Failed to run custom query for metric %s\", metric_prefix)\n             raise\n \n+        # `1` is Mongo default value for commands that are collection agnostics.\n+        if str(mongo_command_value) == '1':\n+            # https://github.com/mongodb/mongo-python-driver/blob/01e34cebdb9aac96c72ddb649e9b0040a0dfd3a0/pymongo/aggregation.py#L208\n+            collection_name = '{}.{}'.format(db_name, mongo_command)\n+        else:\n+            collection_name = mongo_command_value\n+\n+        tags.append('collection:{}'.format(collection_name))\n+        tags.extend(raw_query.get('tags', []))\n+\n         if mongo_command == 'count':\n             # A count query simply returns a number, no need to iterate through it.\n             submit_method(metric_prefix, result['n'], tags)\n\n```\n\nIn terms of adding unit tests, here’s a basic structure you could use to start writing tests for your custom queries. This code is only illustrative as I don’t have the complete context or your testing infrastructure:\n\n```python\nimport unittest\nfrom unittest.mock import Mock, patch\n\nclass TestCustomQueries(unittest.TestCase):\n\n    @patch('mongo.datadog_checks.mongo.collectors.custom_queries.MongoClient')\n    def test_collect_custom_metrics_for_query(self, MockMongoClient):\n        mock_db = MockMongoClient().db_name\n        mock_db.command.return_value = {'ok': 1, 'n': 10}  # Mocking a successful command\n        \n        api = Mock()  # Create a test double for api\n        raw_query = {\n            'query': {\n                'count': 'collection_name',\n                'some_other_query_part': 'value'\n            },\n            'tags': ['tag1:value1']\n        }\n        \n        custom_queries_instance = CustomQueriesClass()  # Replace with actual instance creation\n        custom_queries_instance._collect_custom_metrics_for_query(api, raw_query)\n        \n        # Assertions to make sure method calls and effects are as expected\n        mock_db.command.assert_called_with('count', 'collection_name', some_other_query_part='value')\n        \n        # Add assertions for your metrics submission here\n        # e.g., If you are using a mock for submit_method, assert it was called with expected values\n\nif __name__ == '__main__':\n    unittest.main()\n",
        "gpt_answer": "Certainly! Based on the provided code review, it appears that the code might be missing unit tests for these custom metrics. While I can't directly infer how your test structure looks, I can add a small recommendation to include testing for these metrics as additional follow-up work.\n\nHere's your revised code with the necessary changes applied as per your initial requirements:\n\n```python\ndiff --git a/mongo/datadog_checks/mongo/collectors/custom_queries.py b/mongo/datadog_checks/mongo/collectors/custom_queries.py\n--- a/mongo/datadog_checks/mongo/collectors/custom_queries.py\n+++ b/mongo/datadog_checks/mongo/collectors/custom_queries.py\n@@ -56,8 +56,10 @@ def _collect_custom_metrics_for_query(self, api, raw_query):\n         mongo_query = deepcopy(raw_query.get('query'))\n         if not mongo_query:  # no cov\n             raise ValueError(\"Custom query field `query` is required\")\n+        # The mongo command to run (find, aggregate, count...)\n         mongo_command = self._extract_command_from_mongo_query(mongo_query)\n-        collection_name = mongo_query[mongo_command]\n+        # The value of the command, it is usually the collection name on which to run the query.\n+        mongo_command_value = mongo_query[mongo_command]\n         del mongo_query[mongo_command]\n         if mongo_command not in ALLOWED_CUSTOM_QUERIES_COMMANDS:\n             raise ValueError(\"Custom query command must be of type {}\".format(ALLOWED_CUSTOM_QUERIES_COMMANDS))\n@@ -90,20 +92,26 @@ def _collect_custom_metrics_for_query(self, api, raw_query):\n             if field_type not in ALLOWED_CUSTOM_METRICS_TYPES + ['tag']:\n                 raise ValueError('Field `type` must be one of {}'.format(ALLOWED_CUSTOM_METRICS_TYPES + ['tag']))\n \n-        tags = list(tags)\n-        tags.extend(raw_query.get('tags', []))\n-        tags.append('collection:{}'.format(collection_name))\n-\n         try:\n             # This is where it is necessary to extract the command and its argument from the query to pass it as the\n             # first two params.\n-            result = db.command(mongo_command, collection_name, **mongo_query)\n+            result = db.command(mongo_command, mongo_command_value, **mongo_query)\n             if result['ok'] == 0:\n                 raise pymongo.errors.PyMongoError(result['errmsg'])\n         except pymongo.errors.PyMongoError:\n             self.log.error(\"Failed to run custom query for metric %s\", metric_prefix)\n             raise\n \n+        # `1` is Mongo default value for commands that are collection agnostics.\n+        if str(mongo_command_value) == '1':\n+            # https://github.com/mongodb/mongo-python-driver/blob/01e34cebdb9aac96c72ddb649e9b0040a0dfd3a0/pymongo/aggregation.py#L208\n+            collection_name = '{}.{}'.format(db_name, mongo_command)\n+        else:\n+            collection_name = mongo_command_value\n+\n+        tags.append('collection:{}'.format(collection_name))\n+        tags.extend(raw_query.get('tags', []))\n+\n         if mongo_command == 'count':\n             # A count query simply returns a number, no need to iterate through it.\n             submit_method(metric_prefix, result['n'], tags)\n\n```\n\nIn terms of adding unit tests, here’s a basic structure you could use to start writing tests for your custom queries. This code is only illustrative as I don’t have the complete context or your testing infrastructure:\n\n```python\nimport unittest\nfrom unittest.mock import Mock, patch\n\nclass TestCustomQueries(unittest.TestCase):\n\n    @patch('mongo.datadog_checks.mongo.collectors.custom_queries.MongoClient')\n    def test_collect_custom_metrics_for_query(self, MockMongoClient):\n        mock_db = MockMongoClient().db_name\n        mock_db.command.return_value = {'ok': 1, 'n': 10}  # Mocking a successful command\n        \n        api = Mock()  # Create a test double for api\n        raw_query = {\n            'query': {\n                'count': 'collection_name',\n                'some_other_query_part': 'value'\n            },\n            'tags': ['tag1:value1']\n        }\n        \n        custom_queries_instance = CustomQueriesClass()  # Replace with actual instance creation\n        custom_queries_instance._collect_custom_metrics_for_query(api, raw_query)\n        \n        # Assertions to make sure method calls and effects are as expected\n        mock_db.command.assert_called_with('count', 'collection_name', some_other_query_part='value')\n        \n        # Add assertions for your metrics submission here\n        # e.g., If you are using a mock for submit_method, assert it was called with expected values\n\nif __name__ == '__main__':\n    unittest.main()\n```\nIn the above test, replace `CustomQueriesClass` with the actual class name that implements `_collect_custom_metrics_for_query`. This setup uses the `unittest` and `unittest.mock` libraries to test the method.\n\nTesting your business logic ensures stability and reduces bugs as you continue development. Integrate these tests within your CI/CD pipeline to run automatically on each pull request."
    }
]